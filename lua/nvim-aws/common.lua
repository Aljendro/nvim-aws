local config = require("nvim-aws").config
local log = require("utilities.log")

local M = {}

local default_env = {
	["AWS_REGION"] = config.aws.aws_region,
	["AWS_PROFILE"] = config.aws.aws_profile,
	["AWS_ENDPOINT_URL"] = config.aws.aws_endpoint_url,
	["AWS_PAGER"] = "",
	["AWS_DEFAULT_OUTPUT"] = "json",
	["PATH"] = os.getenv("PATH") or "",
}

--- Execute an AWS CLI command with input and process the results
--- Return an empty table if input is nil
--- @param command_path table the aws command path
--- @param input table|nil the input table
--- @param callbacks table|nil {on_start = function(), on_stdout = function(line), on_stderr = function(err), on_exit = function(code)}
--- @return {success: boolean, data: table|nil, error: string|nil }|{success: boolean, job: Job }
function M.execute_aws_command(command_path, input, callbacks)
	if not input then
		return { success = true, data = {} }
	else
		return M.execute_aws_job(vim.list_extend(command_path, input), callbacks)
	end
end

--- Execute an AWS CLI command with an input generated from --generate-cli-skeleton and process the results
--- Return a table that was generated by --generate-cli-skeleton
--- @param command_path table the aws command path
--- @param input table|nil the input table
--- @param callbacks table|nil {on_start = function(), on_stdout = function(line), on_stderr = function(err), on_exit = function(code)}
--- @return {success: boolean, data: table|nil, error: string|nil }|{success: boolean, job: Job }
function M.execute_aws_command_skeleton(command_path, input, callbacks)
	if not input then
		return M.execute_aws_job(vim.list_extend(command_path, { "--generate-cli-skeleton" }), callbacks)
	else
		if next(input) == nil then
			return M.execute_aws_job(vim.list_extend(command_path, { "--cli-input-json", "{}" }), callbacks)
		else
			local json_input = vim.fn.json_encode(input)
			return M.execute_aws_job(vim.list_extend(command_path, { "--cli-input-json", json_input }), callbacks)
		end
	end
end

--- Execute an AWS CLI command and process the results
--- @param args table The arguments for the AWS CLI command
--- @param callbacks table|nil {on_start = function(), on_stdout = function(line), on_stderr = function(err), on_exit = function(code)}
--- @return {success: boolean, data: table|nil, error: string|nil }
function M.execute_aws_job(args, callbacks)
	local concatenated_args = table.concat(args, " ")
	local stderr_result = {}

	if callbacks then
		local on_start = function()
			log.info("starting job: aws " .. concatenated_args .. "...")
			if callbacks.on_start then
				callbacks.on_start()
			end
		end

		-- Call on_start immediately since vim.system doesn't have an on_start callback
		on_start()

		local system_obj = vim.system({ "aws", unpack(args) }, {
			env = default_env,
			text = true,
			stdout = function(_, data) if callbacks.on_stdout and data then
					callbacks.on_stdout(nil, data)
				end
			end,
			stderr = function(_, data)
				if callbacks.on_stderr and data then
					callbacks.on_stderr(nil, data)
				end
			end,
		}, function(obj)
			if callbacks.on_exit then
				callbacks.on_exit(nil, obj.code)
			end
			log.info("finished job: aws " .. concatenated_args .. " with code " .. obj.code)
		end)

		return { success = true, job = system_obj }
	else
		-- Synchronous execution
		local obj = vim.system({ "aws", unpack(args) }, { env = default_env, text = true }):wait()

		if obj.code == 0 then
			log.info("successful job: aws " .. concatenated_args)
			local result = obj.stdout or ""

			-- Handle empty responses
			if result == "" then
				log.debug("successful job: empty response: aws " .. concatenated_args)
				return { success = true, data = {} }
			end

			local parsed_data = vim.json.decode(result, { luanil = { object = true, array = true } })
			log.debug(parsed_data)
			return { success = true, data = parsed_data }
		else
			local err = obj.stderr or "Unknown error"
			log.error("failed job: aws " .. concatenated_args .. ": " .. err)
			return { success = false, error = err }
		end
	end
end

return M
